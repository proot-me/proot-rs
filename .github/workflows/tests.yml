name: Tests

on: [push, pull_request]

env:
  CARGO_TERM_COLOR: always

jobs:
  lints:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
    - uses: actions/checkout@v2
      with:
        fetch-depth: 0
    - name: Setup components
      run: rustup component add clippy rustfmt
    - name: Check code style
      shell: bash
      run: |
        set +o pipefail

        # Determine the two commits to be compared
        if [ "$GITHUB_BASE_REF" ]; then # is pull_request event
          before_commit=${{ github.event.pull_request.base.sha }}
        else # is push event
          if [ "${{ github.event.before }}" = "0000000000000000000000000000000000000000" ]; then
            before_commit="$(git rev-parse HEAD~1)"
          else
            before_commit=${{ github.event.before }}
          fi
        fi
        after_commit=$GITHUB_SHA
        echo "before_commit: ${before_commit} after_commit: ${after_commit}"
        git fetch origin "${before_commit}" --depth=1

        # Run Shell code issues check
        git diff --name-only "${before_commit}".."${after_commit}" | grep '\.sh$' | xargs --no-run-if-empty ls -1df 2>/dev/null | xargs --no-run-if-empty shellcheck || { echo "shell check failed and exit"; exit 1; }
        echo 'Shell code issues check passed.'

        # Run Rust code formatting check
        has_issues=0
        for file in $(git diff --name-only "${before_commit}".."${after_commit}" | grep '\.rs$'); do
            if [ -f "${file}" ] && ! rustfmt --edition 2018 --check --color auto "${file}"; then
                echo ""
                has_issues=1
            fi
        done
        if [ ${has_issues} -eq 0 ]; then
            echo 'Code formatting check passed.'
        else
            echo 'Code formatting issues detected.'
            exit 1
        fi
    - name: Run clippy check
      shell: bash
      run: |
        # There is a bit of a Hack here:
        # Since we just want to do a clippy check, not a heavy build task. We can get the clippy check to continue by creating an empty file.
        touch proot-rs/src/kernel/execve/loader-shim
        cargo clippy

  tests:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
    - uses: actions/checkout@v2
    - name: Install cargo-make
      uses: actions-rs/cargo@v1
      with:
        toolchain: stable
        command: install
        args: --debug cargo-make
    - name: Build
      run: cargo make build
    - name: Setup rootfs
      shell: bash
      run: |
        bash scripts/mkrootfs.sh -d ./rootfs
    - name: Run unit tests
      shell: bash
      run: |
        PROOT_TEST_ROOTFS="$(pwd)/rootfs" cargo test --package=proot-rs --verbose -- --nocapture
    - name: Setup bats-core
      uses: mig4/setup-bats@v1
      with:
        bats-version: 1.3.0
    - name: Run integration tests
      shell: bash
      run: |
        PROOT_TEST_ROOTFS="$(pwd)/rootfs" bats -r tests

  cross-compile:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        target:
          - x86_64-unknown-linux-musl
          - x86_64-unknown-linux-gnu
          - x86_64-linux-android
          - i686-unknown-linux-musl
          - i686-unknown-linux-gnu
          - i686-linux-android
          - armv7-unknown-linux-musleabihf
          - armv7-unknown-linux-gnueabihf
          - arm-linux-androideabi
          - aarch64-unknown-linux-musl
          - aarch64-unknown-linux-gnu
          - aarch64-linux-android
    steps:
      - uses: actions/checkout@v2
      - name: Install cargo-make
        uses: actions-rs/cargo@v1
        with:
          toolchain: stable
          command: install
          args: --debug cargo-make
      - name: Build proot-rs
        uses: actions-rs/cargo@v1
        with:
          command: make
          args: build
          use-cross: true
        env:
          USE_CROSS: true
          CARGO_BUILD_TARGET: ${{ matrix.target }}
      - name: Build archive
        shell: bash
        run: |
          asset_name="proot-rs-${{ github.ref }}-${{ matrix.target }}"
          cp "target/${{ matrix.target }}/debug/proot-rs" "${asset_name}"
          tar czf "${asset_name}.tar.gz" "${asset_name}"
          echo "ASSET=${asset_name}.tar.gz" >> $GITHUB_ENV
      - name: Upload artifact
        uses: actions/upload-artifact@v2
        with:
          name: proot-rs-${{ matrix.target }}
          path: ${{ env.ASSET }}